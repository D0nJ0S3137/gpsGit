<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Consulta de Históricos</title>
  <link rel="stylesheet" href="https://npmcdn.com/flatpickr/dist/themes/dark.css">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
   <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
   <link rel="stylesheet" type="text/css" href="consulta_styles.css">
   <script src="https://cdn.jsdelivr.net/npm/gaugeJS/dist/gauge.min.js"></script>
</head>
<body>
<nav class="navbar navbar-expand-lg" style="background-color: #ffeb3b;">
    <div class="container-fluid">
        <div style="display: flex; align-items: center;">
            <a class="navbar-brand" href="#">
                <span>Tracker Truck</span>
            </a>
            <img src="/logo_TT.png" alt="Tracker Truck Logo" style="height: 60px; width: auto; border-radius: 0%; margin-left: 5px;">
        </div>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
            data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
            aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse justify-content-end" id="navbarSupportedContent">
            <ul class="navbar-nav">
                <a type="button" class="btn btn-dark btn-consistent-size me-2" href="/">
                    <b>Página Principal</b>
                </a>
                <button type="button" class="btn btn-dark btn-consistent-size" data-bs-toggle="modal" data-bs-target="#instructionsModal">
                    <b>Instrucciones de Usuario</b>
                </button>
            </ul>
        </div>        
    </div>
</nav>
    
<div class="container-map">
    <div class="row">
        <div class="col-12">
            <h1 class="text-center my-3 small-title">Consulta de Recorridos</h1>
        </div>
    </div>

</div>
<div class="container">
    <div class="row justify-content-center mb-3">
        <div class="col-lg-8">
            <div class="card">
                <div class="card-body">
                    <div id="timeWindowForm" class="row">
                        <div class="col-md-4">
                            <label for="startDateTime" class="form-label">Fecha y hora de inicio:</label>
                            <input type="text" id="startDateTime" onchange="updateDateTimeDisplay()" required>
                        </div>
                        <div class="col-md-4">
                            <label for="endDateTime" class="form-label">Fecha y hora de fin:</label>
                            <input type="text" id="endDateTime" onchange="updateDateTimeDisplay()" required>
                        </div>
                        <span id="startDateSpan"></span> <span id="startTimeSpan"></span>
                        <span id="endDateSpan"></span> <span id="endTimeSpan"></span>
                        <div class="col-md-4 d-flex align-items-end"> 
                            <button type="submit" id="submitButton" class="btn btn-custom btn-sm w-100" style="background-color: #efb810; color: white;">Mostrar en mapa</button>

                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<div class="modal fade" id="instructionsModal" tabindex="-1" aria-labelledby="instructionsModalLabel" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="instructionsModalLabel">Cómo usar la Consulta de Recorridos</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          Bienvenid@ a la Consulta de Recorridos. Aquí debes:
          <ul>
            <li>Seleccionar rango de fecha y hora de inicio y fin para ver el recorrido histórico del vehículo.</li>
            <li>Dar click en Mostrar en mapa.</li>
            <li>Usar el botón deslizante para moverte a través del recorrido del vehículo y visualizar la fecha y el tiempo donde estuvo en cierto lugar.</li>
          </ul>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cerrar</button>
        </div>
      </div>
    </div>
  </div>

<div class="container">
    <div class="row justify-content-center my-3">
        <div class="col-lg-8">
            <input type="range" class="form-range" min="0" max="100" value="0" id="timeSlider">
        </div>
    </div>

    <div class="row">
        <div class="row">
            <div class="col-12" style="position: relative;">
                <div id="mapid" style="height: 600px;"></div>
                <canvas id="rpmGaugeMap" style="position: absolute; bottom: 20px; right: 20px; width: 300px; height: 160px;"></canvas>
            </div>     
        </div>
        
    </div>
       
</div>

<div id="dateError" class="text-danger"></div>

<script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js"
        integrity="sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r"
        crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js"
        integrity="sha384-0pUGZvbkm6XF6gxjEnlmuGrJXVbNuzT9qBBavbLwCsOGabYfZo0T0to5eqruptLy"
        crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.0/socket.io.js"></script>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-polylinedecorator/dist/leaflet.polylineDecorator.js"></script>
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
// Inicialización de Flatpickr para la fecha de inicio
var startFlatpickr = flatpickr("#startDateTime", {
    enableTime: true,
    dateFormat: "Y-m-dTH:i",
    altInput: true,
    altFormat: "Y-m-d H:i",
    time_24hr: false,
    minuteIncrement: 15,
    altInputClass: "form-control form-control-sm",
    onChange: function(selectedDates) {
        // Cuando se selecciona una nueva fecha de inicio, actualiza la fecha mínima del calendario de fecha de fin
        endFlatpickr.set('minDate', selectedDates[0]);
    }
});

// Inicialización de Flatpickr para la fecha de fin
var endFlatpickr = flatpickr("#endDateTime", {
    enableTime: true,
    dateFormat: "Y-m-dTH:i",
    altInput: true,
    altFormat: "Y-m-d H:i",
    time_24hr: false,
    minuteIncrement: 15,
    altInputClass: "form-control form-control-sm",
    // Se puede especificar una fecha mínima inicial si es necesario, por ejemplo, la fecha actual
    minDate: "today"
});
function openFlatpickrs() {
    startFlatpickr.open();
    endFlatpickr.open();
}


    // cambio para desconcatenar los calendarios
    document.addEventListener('DOMContentLoaded', () => {
    const startDateTimeInput = document.getElementById('startDateTime');
    const endDateTimeInput = document.getElementById('endDateTime');
    const submitButton = document.getElementById('submitButton');
    const errorMessage = document.getElementById('dateError');

    submitButton.addEventListener('click', (event) => {
        event.preventDefault(); // Prevenir el envío del formulario por defecto
        
        const startDateTime = new Date(startDateTimeInput.value);
        const endDateTime = new Date(endDateTimeInput.value);

        if (startDateTime > endDateTime) {
            errorMessage.innerText = "La fecha de inicio no puede ser posterior a la fecha de fin.";
        } else {
            errorMessage.innerText = ""; // Limpiar el mensaje de error si las fechas son válidas
        }
    });

    // Bloquear la entrada de fechas futuras en el campo "Fecha y hora de inicio"
    const today = new Date().toISOString().split('T')[0]; // Obtener la fecha actual en formato ISO
    startDateTimeInput.setAttribute('min', today);
    
    // Bloquear la entrada de fechas anteriores a la fecha de inicio en el campo "Fecha y hora de fin"
    startDateTimeInput.addEventListener('change', () => {
        endDateTimeInput.setAttribute('min', startDateTimeInput.value);
    });
});
</script>

<script>
    let markers = [];
    let trayectos = []; // Almacena las polilíneas de cada trayecto
    let rutaActual;
    let decoradores = []; // Almacena las instancias de los decoradores de flechas
    let rpmGaugeHistoric;

    document.addEventListener('DOMContentLoaded', () => {
        const myMap = L.map('mapid').setView([11.02115114, -74.84057200], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(myMap);
        
        // Inicializar el tacómetro
        rpmGaugeHistoric = new Gauge(document.getElementById("rpmGaugeMap")).setOptions({
            angle: 0.20, 
                lineWidth: 0.20,
                radiusScale: 1,
                pointer: {
                    length: 0.5, // Relativo al radio del gauge
                    strokeWidth: 0.035, // El grosor del puntero
                    color: '#000000' // Color del puntero
                },
                limitMax: false, // Si es false, el valor máximo del gauge se actualiza si el valor supera el max actual
                limitMin: false, // Si es true, el valor mínimo del gauge será 0
                colorStart: '#FFC107', // Color en el inicio del gauge
                colorStop: '#FFC107', // Color en el final del gauge
                strokeColor: '#E0E0E0', // Color de fondo del gauge
                generateGradient: true,
                highDpiSupport: true,
                staticLabels: {
                    font: "14px sans-serif", // Especifica el tipo de letra
                    labels: [0, 2000, 4000, 6000, 8000], // Establece etiquetas en estos valores
                    color: "#000000", // Color de las etiquetas
                    fractionDigits: 0  // Número de cifras decimales
                },
                staticZones: [
                    {strokeStyle: "#F03E3E", min: 0, max: 2000}, // Rojo de 0 a 2000
                    {strokeStyle: "#3498DB", min: 2000, max: 4000}, // Azul claro de 2000 a 4000
                    {strokeStyle: "#2980B9", min: 4000, max: 6000}, // Verde de 4000 a 6000
                    {strokeStyle: "#30B32D", min: 6000, max: 8000} // Azul oscuro de 6000 a 8000 
                ],
        });
        rpmGaugeHistoric.maxValue = 8000; // valor máximo del tacómetro
        rpmGaugeHistoric.setMinValue(0);  // valor mínimo del tacómetro
        rpmGaugeHistoric.set(0); // Establece un valor inicial
        console.log("rpmGaugeHistoric inicializado:", rpmGaugeHistoric);


        document.getElementById('submitButton').addEventListener('click', (event) => {
            event.preventDefault(); // Previene la acción por defecto del formulario
            const startDateTime = document.getElementById('startDateTime').value;
            const endDateTime = document.getElementById('endDateTime').value;

            // Actualiza y muestra la fecha y hora seleccionadas
            updateDateTimeDisplay(startDateTime, endDateTime);

            // Carga los datos para el intervalo de tiempo seleccionado
            cargarDatos(startDateTime, endDateTime, myMap);
        });
        if (!localStorage.getItem('hasSeenInstructions')) {
            console.log('Mostrando modal');
            var myModal = new bootstrap.Modal(document.getElementById('instructionsModal'), {
                keyboard: false
            });
            myModal.show();
            localStorage.setItem('hasSeenInstructions', 'true');
        }
    });

    let marcadorDeslizable; //definición de marcador deslizable
        function cargarDatos(startDateTime, endDateTime, myMap) {
            const link = `/consulta-historicos?startDateTime=${startDateTime}&endDateTime=${endDateTime}`; 
            fetch(link)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log(data);
                    if (data.length > 0) {
                        // Eliminar trayectos existentes y limpiar el arreglo
                        trayectos.forEach(trayecto => trayecto.remove());
                        trayectos = [];

                        // Eliminar marcadores existentes y limpiar el arreglo
                        markers.forEach(marker => marker.remove());
                        markers = [];

                        decoradores.forEach(decorador => decorador.remove());
                        decoradores = [];

                        rutaActual = L.polyline([], {
                            color: 'blue',      // Cambia el color a azul o el que prefieras
                            weight: 3,          // Ajusta el grosor de la línea
                            opacity: 0.7,       // Ajusta la opacidad de la línea
                            lineJoin: 'round',  // Establece cómo se unen los segmentos de la línea ('miter' es predeterminado, 'round' o 'bevel')
                        }).addTo(myMap);

                        trayectos.push(rutaActual);

                        let ultimoPunto = null;
                        data.forEach(point => {
                            const lat = parseFloat(point.Latitude); 
                            const lng = parseFloat(point.Longitude);
                            const nuevoPunto = L.latLng(lat, lng);

                            if (ultimoPunto && myMap.distance(ultimoPunto, nuevoPunto) > 500) {
                                if (ultimoPunto) {
                        let decorador = L.polylineDecorator(rutaActual, {
                            patterns: [
                                {offset: '5%', repeat: '50px', symbol: L.Symbol.arrowHead({pixelSize: 10, pathOptions: {opacity: 0.7, color: 'blue', weight: 3}})}
                            ]
                        }).addTo(myMap);
                        decoradores.push(decorador);
                    }
                    
                    // Comienza un nuevo segmento
                    rutaActual = L.polyline([], { color: 'blue', weight: 3, opacity: 0.7, lineJoin: 'round' }).addTo(myMap);
                    trayectos.push(rutaActual);
                }

                // Añade el nuevo punto al segmento actual
                rutaActual.addLatLng(nuevoPunto);
                ultimoPunto = nuevoPunto;
            });

            // Decora el último segmento después de salir del bucle forEach
            if (rutaActual.getLatLngs().length > 0) {
                let decorador = L.polylineDecorator(rutaActual, {
                    patterns: [
                        {offset: '5%', repeat: '50px', symbol: L.Symbol.arrowHead({pixelSize: 10, pathOptions: {opacity: 0.7, color: 'blue', weight: 3}})}
                    ]
                }).addTo(myMap);
                decoradores.push(decorador);
            }
                        //implementación de slider
                        if (!marcadorDeslizable) {
                            marcadorDeslizable = L.marker([0, 0], {
                                draggable: 'true',
                            }).addTo(myMap);
                        }
                        const slider = document.getElementById('timeSlider');
                        slider.max = data.length - 1;
                        slider.value = 0;

                        slider.oninput = function() {
                            const puntoSeleccionado = data[this.value];
                            console.log("Intentando establecer RPM en tacómetro:", rpmGaugeHistoric);
                            const latLng = L.latLng(puntoSeleccionado.Latitude, puntoSeleccionado.Longitude);
                            marcadorDeslizable.setLatLng(latLng);
                            marcadorDeslizable.bindPopup(`Fecha y Hora de Paso: ${puntoSeleccionado.DateTime}`).openPopup(); 
                            myMap.setView(latLng, myMap.getZoom());
                            if (rpmGaugeHistoric) {
                                rpmGaugeHistoric.set(puntoSeleccionado.RPM);
                            } else {
                                console.error('rpmGaugeHistoric no está definido');
                            }
                        };

                        slider.oninput();

                        document.getElementById('timeSlider').style.display = 'block'; 
                    } else {
                        alert("No hay datos de ruta disponibles para la ventana de tiempo seleccionada.");
                        document.getElementById('timeSlider').style.display = 'none';
                    }
                })
                .catch(error => {
                    console.error('Error en fetch o procesando data:', error);
                    alert("Hubo un problema al cargar los datos.");
                    document.getElementById('timeSlider').style.display = 'none';
                });
        }
    function updateDateTimeDisplay() {
        const startDateTimeStr = document.getElementById('startDateTime').value;
        const endDateTimeStr = document.getElementById('endDateTime').value;

        if (startDateTimeStr && endDateTimeStr) {
                const [startDate, startTime] = startDateTimeStr.split(' ');
                const [endDate, endTime] = endDateTimeStr.split(' ');

                document.getElementById('startDateSpan').textContent = startDate;
                document.getElementById('startTimeSpan').textContent = startTime;
                document.getElementById('endDateSpan').textContent = endDate;
                document.getElementById('endTimeSpan').textContent = endTime;
        }
    }
</script>

